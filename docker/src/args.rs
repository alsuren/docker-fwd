use argh::FromArgs;

/// run docker on a remote host
#[derive(Debug, PartialEq, FromArgs)]
pub struct Docker {
    #[argh(subcommand)]
    pub subcommand: Subcommand,
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand)]
pub enum Subcommand {
    Run(Run),
}

/// generated by semi-automatic text-processing of `docker run --help
#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "run")]
pub struct Run {
    #[argh(positional)]
    pub image_command_arg: Vec<String>,
    /// add a custom host-to-IP mapping (host:ip)
    #[argh(option)]
    pub add_host: Vec<String>,
    /// attach to STDIN, STDOUT or STDERR
    #[argh(option, short = 'a')]
    pub attach: Vec<String>,
    /// block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)
    #[argh(option)]
    pub blkio_weight: Option<String>, // uint16
    /// block IO weight (relative device weight) (default [])
    #[argh(option)]
    pub blkio_weight_device: Vec<String>,
    /// add Linux capabilities
    #[argh(option)]
    pub cap_add: Vec<String>,
    /// drop Linux capabilities
    #[argh(option)]
    pub cap_drop: Vec<String>,
    /// optional parent cgroup for the container
    #[argh(option)]
    pub cgroup_parent: Option<String>, // string
    /// write the container ID to the file
    #[argh(option)]
    pub cidfile: Option<String>, // string
    /// limit CPU CFS (Completely Fair Scheduler) period
    #[argh(option)]
    pub cpu_period: Option<String>, // int
    /// limit CPU CFS (Completely Fair Scheduler) quota
    #[argh(option)]
    pub cpu_quota: Option<String>, // int
    /// limit CPU real_time period in microseconds
    #[argh(option)]
    pub cpu_rt_period: Option<String>, // int
    /// limit CPU real_time runtime in microseconds
    #[argh(option)]
    pub cpu_rt_runtime: Option<String>, // int
    /// cPU shares (relative weight)
    #[argh(option, short = 'c')]
    pub cpu_shares: Option<String>, // int
    /// number of CPUs
    #[argh(option)]
    pub cpus: Option<String>, // decimal
    /// cPUs in which to allow execution (0_3, 0,1)
    #[argh(option)]
    pub cpuset_cpus: Option<String>, // string
    /// mEMs in which to allow execution (0_3, 0,1)
    #[argh(option)]
    pub cpuset_mems: Option<String>, // string
    /// run container in background and print container ID
    #[argh(option, short = 'd')]
    pub detach: Option<String>, //
    /// override the key sequence for detaching a container
    #[argh(option)]
    pub detach_keys: Option<String>, // string
    /// add a host device to the container
    #[argh(option)]
    pub device: Vec<String>,
    /// add a rule to the cgroup allowed devices list
    #[argh(option)]
    pub device_cgroup_rule: Vec<String>,
    /// limit read rate (bytes per second) from a device (default [])
    #[argh(option)]
    pub device_read_bps: Vec<String>,
    /// limit read rate (IO per second) from a device (default [])
    #[argh(option)]
    pub device_read_iops: Vec<String>,
    /// limit write rate (bytes per second) to a device (default [])
    #[argh(option)]
    pub device_write_bps: Vec<String>,
    /// limit write rate (IO per second) to a device (default [])
    #[argh(option)]
    pub device_write_iops: Vec<String>,
    /// skip image verification (default true)
    #[argh(option)]
    pub disable_content_trust: Option<String>,
    /// set custom DNS servers
    #[argh(option)]
    pub dns: Vec<String>,
    /// set DNS options
    #[argh(option)]
    pub dns_option: Vec<String>,
    /// set custom DNS search domains
    #[argh(option)]
    pub dns_search: Vec<String>,
    /// overwrite the default ENTRYPOINT of the image
    #[argh(option)]
    pub entrypoint: Option<String>, // string
    /// set environment variables
    #[argh(option, short = 'e')]
    pub env: Vec<String>,
    /// read in a file of environment variables
    #[argh(option)]
    pub env_file: Vec<String>,
    /// expose a port or a range of ports
    #[argh(option)]
    pub expose: Vec<String>,
    /// add additional groups to join
    #[argh(option)]
    pub group_add: Vec<String>,
    /// command to run to check health
    #[argh(option)]
    pub health_cmd: Option<String>, // string
    /// time between running the check (ms|s|m|h) (default 0s)
    #[argh(option)]
    pub health_interval: Option<String>, // duration
    /// consecutive failures needed to report unhealthy
    #[argh(option)]
    pub health_retries: Option<String>, // int
    /// start period for the container to initialize before starting health_retries countdown (ms|s|m|h) (default 0s)
    #[argh(option)]
    pub health_start_period: Option<String>, // duration
    /// maximum time to allow one check to run (ms|s|m|h) (default 0s)
    #[argh(option)]
    pub health_timeout: Option<String>, // duration
    /// container host name
    #[argh(option, short = 'h')]
    pub hostname: Option<String>, // string
    /// run an init inside the container that forwards signals and reaps processes
    #[argh(switch)]
    pub init: bool,
    /// keep STDIN open even if not attached
    #[argh(option, short = 'i')]
    pub interactive: Option<String>, //
    /// iPv4 address (e.g., 172.30.100.104)
    #[argh(option)]
    pub ip: Option<String>, // string
    /// iPv6 address (e.g., 2001:db8::33)
    #[argh(option)]
    pub ip6: Option<String>, // string
    /// iPC mode to use
    #[argh(option)]
    pub ipc: Option<String>, // string
    /// container isolation technology
    #[argh(option)]
    pub isolation: Option<String>, // string
    /// kernel memory limit
    #[argh(option)]
    pub kernel_memory: Option<String>, // bytes
    /// set meta data on a container
    #[argh(option, short = 'l')]
    pub label: Vec<String>,
    /// read in a line delimited file of labels
    #[argh(option)]
    pub label_file: Vec<String>,
    /// add link to another container
    #[argh(option)]
    pub link: Vec<String>,
    /// container IPv4/IPv6 link_local addresses
    #[argh(option)]
    pub link_local_ip: Vec<String>,
    /// logging driver for the container
    #[argh(option)]
    pub log_driver: Option<String>, // string
    /// log driver options
    #[argh(option)]
    pub log_opt: Vec<String>,
    /// container MAC address (e.g., 92:d0:c6:0a:29:33)
    #[argh(option)]
    pub mac_address: Option<String>, // string
    /// memory limit
    #[argh(option, short = 'm')]
    pub memory: Option<String>, // bytes
    /// memory soft limit
    #[argh(option)]
    pub memory_reservation: Option<String>, // bytes
    /// swap limit equal to memory plus swap: '_1' to enable unlimited swap
    #[argh(option)]
    pub memory_swap: Option<String>, // bytes
    /// tune container memory swappiness (0 to 100) (default _1)
    #[argh(option)]
    pub memory_swappiness: Option<String>, // int
    /// attach a filesystem mount to the container
    #[argh(option)]
    pub mount: Option<String>, // mount
    /// assign a name to the container
    #[argh(option)]
    pub name: Option<String>, // string
    /// connect a container to a network (default "default")
    #[argh(option)]
    pub network: Option<String>, // string
    /// add network_scoped alias for the container
    #[argh(option)]
    pub network_alias: Vec<String>,
    /// disable any container_specified HEALTHCHECK
    #[argh(option)]
    pub no_healthcheck: Option<String>,
    /// disable OOM Killer
    #[argh(option)]
    pub oom_kill_disable: Option<String>,
    /// tune host's OOM preferences (_1000 to 1000)
    #[argh(option)]
    pub oom_score_adj: Option<String>, // int
    /// pID namespace to use
    #[argh(option)]
    pub pid: Option<String>, // string
    /// tune container pids limit (set _1 for unlimited)
    #[argh(option)]
    pub pids_limit: Option<String>, // int
    /// give extended privileges to this container
    #[argh(switch)]
    pub privileged: bool,
    /// publish a container's port(s) to the host
    #[argh(option, short = 'p')]
    pub publish: Vec<String>,
    /// publish all exposed ports to random ports
    #[argh(option, short = 'P')]
    pub publish_all: Option<String>,
    /// mount the container's root filesystem as read only
    #[argh(option)]
    pub read_only: Option<String>,
    /// restart policy to apply when a container exits (default "no")
    #[argh(option)]
    pub restart: Option<String>, // string
    /// automatically remove the container when it exits
    #[argh(switch)]
    pub rm: bool,
    /// runtime to use for this container
    #[argh(option)]
    pub runtime: Option<String>, // string
    /// security Options
    #[argh(option)]
    pub security_opt: Vec<String>,
    /// size of /dev/shm
    #[argh(option)]
    pub shm_size: Option<String>, // bytes
    /// proxy received signals to the process (default true)
    #[argh(option)]
    pub sig_proxy: Option<String>,
    /// signal to stop a container (default "SIGTERM")
    #[argh(option)]
    pub stop_signal: Option<String>, // string
    /// timeout (in seconds) to stop a container
    #[argh(option)]
    pub stop_timeout: Option<String>, // int
    /// storage driver options for the container
    #[argh(option)]
    pub storage_opt: Vec<String>,
    /// sysctl options (default map[])
    #[argh(option)]
    pub sysctl: Option<String>, // map
    /// mount a tmpfs directory
    #[argh(option)]
    pub tmpfs: Vec<String>,
    /// allocate a pseudo_TTY
    #[argh(option, short = 't')]
    pub tty: Option<String>, //
    /// ulimit options (default [])
    #[argh(option)]
    pub ulimit: Option<String>, // ulimit
    /// username or UID (format: <name|uid>[:<group|gid>])
    #[argh(option, short = 'u')]
    pub user: Option<String>, // string
    /// user namespace to use
    #[argh(option)]
    pub userns: Option<String>, // string
    /// uTS namespace to use
    #[argh(option)]
    pub uts: Option<String>, // string
    /// bind mount a volume
    #[argh(option, short = 'v')]
    pub volume: Vec<String>,
    /// optional volume driver for the container
    #[argh(option)]
    pub volume_driver: Option<String>, // string
    /// mount volumes from the specified container(s)
    #[argh(option)]
    pub volumes_from: Vec<String>,
    /// working directory inside the container
    #[argh(option, short = 'w')]
    pub workdir: Option<String>, // string
}

#[cfg(test)]
mod test {
    use super::*;
    #[test]
    fn understands_run_args() {
        Docker::from_args(&["docker"], &["run", "--rm"]).unwrap();
    }
}
